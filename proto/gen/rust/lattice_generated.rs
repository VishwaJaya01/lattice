// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


#[allow(unused_imports, dead_code)]
pub mod lattice {

#[allow(unused_imports, dead_code)]
pub mod fb {


#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTROL_KIND: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTROL_KIND: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTROL_KIND: [ControlKind; 5] = [
  ControlKind::Unspecified,
  ControlKind::Start,
  ControlKind::Pause,
  ControlKind::Resume,
  ControlKind::Cancel,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ControlKind(pub i8);
#[allow(non_upper_case_globals)]
impl ControlKind {
  pub const Unspecified: Self = Self(0);
  pub const Start: Self = Self(1);
  pub const Pause: Self = Self(2);
  pub const Resume: Self = Self(3);
  pub const Cancel: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unspecified,
    Self::Start,
    Self::Pause,
    Self::Resume,
    Self::Cancel,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unspecified => Some("Unspecified"),
      Self::Start => Some("Start"),
      Self::Pause => Some("Pause"),
      Self::Resume => Some("Resume"),
      Self::Cancel => Some("Cancel"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ControlKind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ControlKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ControlKind {
    type Output = ControlKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ControlKind {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ControlKind {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ControlKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STATUS_KIND: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STATUS_KIND: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STATUS_KIND: [StatusKind; 4] = [
  StatusKind::Unknown,
  StatusKind::Ok,
  StatusKind::Degraded,
  StatusKind::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StatusKind(pub i8);
#[allow(non_upper_case_globals)]
impl StatusKind {
  pub const Unknown: Self = Self(0);
  pub const Ok: Self = Self(1);
  pub const Degraded: Self = Self(2);
  pub const Error: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::Ok,
    Self::Degraded,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::Ok => Some("Ok"),
      Self::Degraded => Some("Degraded"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for StatusKind {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for StatusKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for StatusKind {
    type Output = StatusKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for StatusKind {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for StatusKind {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for StatusKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REQUEST_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REQUEST_PAYLOAD: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST_PAYLOAD: [RequestPayload; 3] = [
  RequestPayload::NONE,
  RequestPayload::HashBatch,
  RequestPayload::ControlMessage,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RequestPayload(pub u8);
#[allow(non_upper_case_globals)]
impl RequestPayload {
  pub const NONE: Self = Self(0);
  pub const HashBatch: Self = Self(1);
  pub const ControlMessage: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::HashBatch,
    Self::ControlMessage,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::HashBatch => Some("HashBatch"),
      Self::ControlMessage => Some("ControlMessage"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for RequestPayload {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for RequestPayload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for RequestPayload {
    type Output = RequestPayload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for RequestPayload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for RequestPayload {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for RequestPayload {}
pub struct RequestPayloadUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPONSE_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPONSE_PAYLOAD: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE_PAYLOAD: [ResponsePayload; 5] = [
  ResponsePayload::NONE,
  ResponsePayload::CrackedHash,
  ResponsePayload::CrackedBatch,
  ResponsePayload::Status,
  ResponsePayload::Error,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResponsePayload(pub u8);
#[allow(non_upper_case_globals)]
impl ResponsePayload {
  pub const NONE: Self = Self(0);
  pub const CrackedHash: Self = Self(1);
  pub const CrackedBatch: Self = Self(2);
  pub const Status: Self = Self(3);
  pub const Error: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CrackedHash,
    Self::CrackedBatch,
    Self::Status,
    Self::Error,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CrackedHash => Some("CrackedHash"),
      Self::CrackedBatch => Some("CrackedBatch"),
      Self::Status => Some("Status"),
      Self::Error => Some("Error"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ResponsePayload {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ResponsePayload {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ResponsePayload {
    type Output = ResponsePayload;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ResponsePayload {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ResponsePayload {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ResponsePayload {}
pub struct ResponsePayloadUnionTableOffset {}

// struct Hash16, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Hash16(pub [u8; 16]);
impl Default for Hash16 { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl ::core::fmt::Debug for Hash16 {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    f.debug_struct("Hash16")
      .field("lo", &self.lo())
      .field("hi", &self.hi())
      .finish()
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Hash16 {}
impl<'a> ::flatbuffers::Follow<'a> for Hash16 {
  type Inner = &'a Hash16;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Hash16>::follow(buf, loc) }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for &'a Hash16 {
  type Inner = &'a Hash16;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { ::flatbuffers::follow_cast_ref::<Hash16>(buf, loc) }
  }
}
impl<'b> ::flatbuffers::Push for Hash16 {
    type Output = Hash16;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Hash16 as *const u8, <Self as ::flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> ::flatbuffers::PushAlignment {
        ::flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> ::flatbuffers::Verifiable for Hash16 {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Hash16 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    lo: u64,
    hi: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_lo(lo);
    s.set_hi(hi);
    s
  }

  pub fn lo(&self) -> u64 {
    let mut mem = ::core::mem::MaybeUninit::<<u64 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_lo(&mut self, x: u64) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn hi(&self) -> u64 {
    let mut mem = ::core::mem::MaybeUninit::<<u64 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_hi(&mut self, x: u64) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        ::core::mem::size_of::<<u64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum HashBatchOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HashBatch<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for HashBatch<'a> {
  type Inner = HashBatch<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> HashBatch<'a> {
  pub const VT_BATCH_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_HASHES: ::flatbuffers::VOffsetT = 6;
  pub const VT_SENT_UNIX_MS: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    HashBatch { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HashBatchArgs<'args>
  ) -> ::flatbuffers::WIPOffset<HashBatch<'bldr>> {
    let mut builder = HashBatchBuilder::new(_fbb);
    builder.add_sent_unix_ms(args.sent_unix_ms);
    if let Some(x) = args.hashes { builder.add_hashes(x); }
    if let Some(x) = args.batch_id { builder.add_batch_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn batch_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(HashBatch::VT_BATCH_ID, None)}
  }
  #[inline]
  pub fn hashes(&self) -> Option<::flatbuffers::Vector<'a, Hash16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, Hash16>>>(HashBatch::VT_HASHES, None)}
  }
  #[inline]
  pub fn sent_unix_ms(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(HashBatch::VT_SENT_UNIX_MS, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for HashBatch<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("batch_id", Self::VT_BATCH_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, Hash16>>>("hashes", Self::VT_HASHES, false)?
     .visit_field::<u64>("sent_unix_ms", Self::VT_SENT_UNIX_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct HashBatchArgs<'a> {
    pub batch_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub hashes: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, Hash16>>>,
    pub sent_unix_ms: u64,
}
impl<'a> Default for HashBatchArgs<'a> {
  #[inline]
  fn default() -> Self {
    HashBatchArgs {
      batch_id: None,
      hashes: None,
      sent_unix_ms: 0,
    }
  }
}

pub struct HashBatchBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> HashBatchBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_batch_id(&mut self, batch_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(HashBatch::VT_BATCH_ID, batch_id);
  }
  #[inline]
  pub fn add_hashes(&mut self, hashes: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , Hash16>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(HashBatch::VT_HASHES, hashes);
  }
  #[inline]
  pub fn add_sent_unix_ms(&mut self, sent_unix_ms: u64) {
    self.fbb_.push_slot::<u64>(HashBatch::VT_SENT_UNIX_MS, sent_unix_ms, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> HashBatchBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HashBatchBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<HashBatch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for HashBatch<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("HashBatch");
      ds.field("batch_id", &self.batch_id());
      ds.field("hashes", &self.hashes());
      ds.field("sent_unix_ms", &self.sent_unix_ms());
      ds.finish()
  }
}
pub enum KeyValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KeyValue<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for KeyValue<'a> {
  type Inner = KeyValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> KeyValue<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    KeyValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KeyValueArgs<'args>
  ) -> ::flatbuffers::WIPOffset<KeyValue<'bldr>> {
    let mut builder = KeyValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)}
  }
}

impl ::flatbuffers::Verifiable for KeyValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyValueArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KeyValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    KeyValueArgs {
      key: None,
      value: None,
    }
  }
}

pub struct KeyValueBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> KeyValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> KeyValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<KeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for KeyValue<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("KeyValue");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ControlMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ControlMessage<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for ControlMessage<'a> {
  type Inner = ControlMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ControlMessage<'a> {
  pub const VT_KIND: ::flatbuffers::VOffsetT = 4;
  pub const VT_REASON: ::flatbuffers::VOffsetT = 6;
  pub const VT_METADATA: ::flatbuffers::VOffsetT = 8;
  pub const VT_BATCH_ID: ::flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ControlMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ControlMessageArgs<'args>
  ) -> ::flatbuffers::WIPOffset<ControlMessage<'bldr>> {
    let mut builder = ControlMessageBuilder::new(_fbb);
    if let Some(x) = args.batch_id { builder.add_batch_id(x); }
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.reason { builder.add_reason(x); }
    builder.add_kind(args.kind);
    builder.finish()
  }


  #[inline]
  pub fn kind(&self) -> ControlKind {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ControlKind>(ControlMessage::VT_KIND, Some(ControlKind::Unspecified)).unwrap()}
  }
  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(ControlMessage::VT_REASON, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KeyValue>>>>(ControlMessage::VT_METADATA, None)}
  }
  #[inline]
  pub fn batch_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(ControlMessage::VT_BATCH_ID, None)}
  }
}

impl ::flatbuffers::Verifiable for ControlMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<ControlKind>("kind", Self::VT_KIND, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("reason", Self::VT_REASON, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<KeyValue>>>>("metadata", Self::VT_METADATA, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("batch_id", Self::VT_BATCH_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct ControlMessageArgs<'a> {
    pub kind: ControlKind,
    pub reason: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub metadata: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>,
    pub batch_id: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ControlMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    ControlMessageArgs {
      kind: ControlKind::Unspecified,
      reason: None,
      metadata: None,
      batch_id: None,
    }
  }
}

pub struct ControlMessageBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ControlMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_kind(&mut self, kind: ControlKind) {
    self.fbb_.push_slot::<ControlKind>(ControlMessage::VT_KIND, kind, ControlKind::Unspecified);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ControlMessage::VT_REASON, reason);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ControlMessage::VT_METADATA, metadata);
  }
  #[inline]
  pub fn add_batch_id(&mut self, batch_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ControlMessage::VT_BATCH_ID, batch_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ControlMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ControlMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ControlMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ControlMessage<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ControlMessage");
      ds.field("kind", &self.kind());
      ds.field("reason", &self.reason());
      ds.field("metadata", &self.metadata());
      ds.field("batch_id", &self.batch_id());
      ds.finish()
  }
}
pub enum CrackedHashOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CrackedHash<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for CrackedHash<'a> {
  type Inner = CrackedHash<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CrackedHash<'a> {
  pub const VT_ORIGINAL_HASH: ::flatbuffers::VOffsetT = 4;
  pub const VT_USERNAME: ::flatbuffers::VOffsetT = 6;
  pub const VT_PLAINTEXT: ::flatbuffers::VOffsetT = 8;
  pub const VT_CHAIN_INFO: ::flatbuffers::VOffsetT = 10;
  pub const VT_BATCH_ID: ::flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    CrackedHash { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrackedHashArgs<'args>
  ) -> ::flatbuffers::WIPOffset<CrackedHash<'bldr>> {
    let mut builder = CrackedHashBuilder::new(_fbb);
    builder.add_chain_info(args.chain_info);
    if let Some(x) = args.batch_id { builder.add_batch_id(x); }
    if let Some(x) = args.plaintext { builder.add_plaintext(x); }
    if let Some(x) = args.username { builder.add_username(x); }
    if let Some(x) = args.original_hash { builder.add_original_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn original_hash(&self) -> Option<&'a Hash16> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Hash16>(CrackedHash::VT_ORIGINAL_HASH, None)}
  }
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(CrackedHash::VT_USERNAME, None)}
  }
  #[inline]
  pub fn plaintext(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(CrackedHash::VT_PLAINTEXT, None)}
  }
  #[inline]
  pub fn chain_info(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CrackedHash::VT_CHAIN_INFO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn batch_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(CrackedHash::VT_BATCH_ID, None)}
  }
}

impl ::flatbuffers::Verifiable for CrackedHash<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<Hash16>("original_hash", Self::VT_ORIGINAL_HASH, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("username", Self::VT_USERNAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("plaintext", Self::VT_PLAINTEXT, false)?
     .visit_field::<u64>("chain_info", Self::VT_CHAIN_INFO, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("batch_id", Self::VT_BATCH_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CrackedHashArgs<'a> {
    pub original_hash: Option<&'a Hash16>,
    pub username: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub plaintext: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub chain_info: u64,
    pub batch_id: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CrackedHashArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrackedHashArgs {
      original_hash: None,
      username: None,
      plaintext: None,
      chain_info: 0,
      batch_id: None,
    }
  }
}

pub struct CrackedHashBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CrackedHashBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_original_hash(&mut self, original_hash: &Hash16) {
    self.fbb_.push_slot_always::<&Hash16>(CrackedHash::VT_ORIGINAL_HASH, original_hash);
  }
  #[inline]
  pub fn add_username(&mut self, username: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CrackedHash::VT_USERNAME, username);
  }
  #[inline]
  pub fn add_plaintext(&mut self, plaintext: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CrackedHash::VT_PLAINTEXT, plaintext);
  }
  #[inline]
  pub fn add_chain_info(&mut self, chain_info: u64) {
    self.fbb_.push_slot::<u64>(CrackedHash::VT_CHAIN_INFO, chain_info, 0);
  }
  #[inline]
  pub fn add_batch_id(&mut self, batch_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CrackedHash::VT_BATCH_ID, batch_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CrackedHashBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrackedHashBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<CrackedHash<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for CrackedHash<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("CrackedHash");
      ds.field("original_hash", &self.original_hash());
      ds.field("username", &self.username());
      ds.field("plaintext", &self.plaintext());
      ds.field("chain_info", &self.chain_info());
      ds.field("batch_id", &self.batch_id());
      ds.finish()
  }
}
pub enum CrackedBatchOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CrackedBatch<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for CrackedBatch<'a> {
  type Inner = CrackedBatch<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> CrackedBatch<'a> {
  pub const VT_BATCH_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_CRACKS: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    CrackedBatch { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrackedBatchArgs<'args>
  ) -> ::flatbuffers::WIPOffset<CrackedBatch<'bldr>> {
    let mut builder = CrackedBatchBuilder::new(_fbb);
    if let Some(x) = args.cracks { builder.add_cracks(x); }
    if let Some(x) = args.batch_id { builder.add_batch_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn batch_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(CrackedBatch::VT_BATCH_ID, None)}
  }
  #[inline]
  pub fn cracks(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CrackedHash<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CrackedHash>>>>(CrackedBatch::VT_CRACKS, None)}
  }
}

impl ::flatbuffers::Verifiable for CrackedBatch<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("batch_id", Self::VT_BATCH_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<CrackedHash>>>>("cracks", Self::VT_CRACKS, false)?
     .finish();
    Ok(())
  }
}
pub struct CrackedBatchArgs<'a> {
    pub batch_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub cracks: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CrackedHash<'a>>>>>,
}
impl<'a> Default for CrackedBatchArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrackedBatchArgs {
      batch_id: None,
      cracks: None,
    }
  }
}

pub struct CrackedBatchBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CrackedBatchBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_batch_id(&mut self, batch_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CrackedBatch::VT_BATCH_ID, batch_id);
  }
  #[inline]
  pub fn add_cracks(&mut self, cracks: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<CrackedHash<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(CrackedBatch::VT_CRACKS, cracks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CrackedBatchBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrackedBatchBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<CrackedBatch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for CrackedBatch<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("CrackedBatch");
      ds.field("batch_id", &self.batch_id());
      ds.field("cracks", &self.cracks());
      ds.finish()
  }
}
pub enum StatusOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Status<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Status<'a> {
  type Inner = Status<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Status<'a> {
  pub const VT_NODE_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_STATUS: ::flatbuffers::VOffsetT = 6;
  pub const VT_RATE_HASHES_PER_SEC: ::flatbuffers::VOffsetT = 8;
  pub const VT_PROCESSED: ::flatbuffers::VOffsetT = 10;
  pub const VT_CRACKED: ::flatbuffers::VOffsetT = 12;
  pub const VT_IN_FLIGHT: ::flatbuffers::VOffsetT = 14;
  pub const VT_TIMESTAMP_UNIX_MS: ::flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Status { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StatusArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Status<'bldr>> {
    let mut builder = StatusBuilder::new(_fbb);
    builder.add_timestamp_unix_ms(args.timestamp_unix_ms);
    builder.add_in_flight(args.in_flight);
    builder.add_cracked(args.cracked);
    builder.add_processed(args.processed);
    builder.add_rate_hashes_per_sec(args.rate_hashes_per_sec);
    if let Some(x) = args.node_id { builder.add_node_id(x); }
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn node_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Status::VT_NODE_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> StatusKind {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StatusKind>(Status::VT_STATUS, Some(StatusKind::Unknown)).unwrap()}
  }
  #[inline]
  pub fn rate_hashes_per_sec(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Status::VT_RATE_HASHES_PER_SEC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn processed(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Status::VT_PROCESSED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cracked(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Status::VT_CRACKED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_flight(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Status::VT_IN_FLIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp_unix_ms(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Status::VT_TIMESTAMP_UNIX_MS, Some(0)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Status<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("node_id", Self::VT_NODE_ID, false)?
     .visit_field::<StatusKind>("status", Self::VT_STATUS, false)?
     .visit_field::<f64>("rate_hashes_per_sec", Self::VT_RATE_HASHES_PER_SEC, false)?
     .visit_field::<u64>("processed", Self::VT_PROCESSED, false)?
     .visit_field::<u64>("cracked", Self::VT_CRACKED, false)?
     .visit_field::<u64>("in_flight", Self::VT_IN_FLIGHT, false)?
     .visit_field::<u64>("timestamp_unix_ms", Self::VT_TIMESTAMP_UNIX_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct StatusArgs<'a> {
    pub node_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub status: StatusKind,
    pub rate_hashes_per_sec: f64,
    pub processed: u64,
    pub cracked: u64,
    pub in_flight: u64,
    pub timestamp_unix_ms: u64,
}
impl<'a> Default for StatusArgs<'a> {
  #[inline]
  fn default() -> Self {
    StatusArgs {
      node_id: None,
      status: StatusKind::Unknown,
      rate_hashes_per_sec: 0.0,
      processed: 0,
      cracked: 0,
      in_flight: 0,
      timestamp_unix_ms: 0,
    }
  }
}

pub struct StatusBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> StatusBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_node_id(&mut self, node_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Status::VT_NODE_ID, node_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: StatusKind) {
    self.fbb_.push_slot::<StatusKind>(Status::VT_STATUS, status, StatusKind::Unknown);
  }
  #[inline]
  pub fn add_rate_hashes_per_sec(&mut self, rate_hashes_per_sec: f64) {
    self.fbb_.push_slot::<f64>(Status::VT_RATE_HASHES_PER_SEC, rate_hashes_per_sec, 0.0);
  }
  #[inline]
  pub fn add_processed(&mut self, processed: u64) {
    self.fbb_.push_slot::<u64>(Status::VT_PROCESSED, processed, 0);
  }
  #[inline]
  pub fn add_cracked(&mut self, cracked: u64) {
    self.fbb_.push_slot::<u64>(Status::VT_CRACKED, cracked, 0);
  }
  #[inline]
  pub fn add_in_flight(&mut self, in_flight: u64) {
    self.fbb_.push_slot::<u64>(Status::VT_IN_FLIGHT, in_flight, 0);
  }
  #[inline]
  pub fn add_timestamp_unix_ms(&mut self, timestamp_unix_ms: u64) {
    self.fbb_.push_slot::<u64>(Status::VT_TIMESTAMP_UNIX_MS, timestamp_unix_ms, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> StatusBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StatusBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Status<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Status<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Status");
      ds.field("node_id", &self.node_id());
      ds.field("status", &self.status());
      ds.field("rate_hashes_per_sec", &self.rate_hashes_per_sec());
      ds.field("processed", &self.processed());
      ds.field("cracked", &self.cracked());
      ds.field("in_flight", &self.in_flight());
      ds.field("timestamp_unix_ms", &self.timestamp_unix_ms());
      ds.finish()
  }
}
pub enum ErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Error<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Error<'a> {
  type Inner = Error<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Error<'a> {
  pub const VT_CODE: ::flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 6;
  pub const VT_DETAILS: ::flatbuffers::VOffsetT = 8;
  pub const VT_BATCH_ID: ::flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Error { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Error<'bldr>> {
    let mut builder = ErrorBuilder::new(_fbb);
    if let Some(x) = args.batch_id { builder.add_batch_id(x); }
    if let Some(x) = args.details { builder.add_details(x); }
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_code(args.code);
    builder.finish()
  }


  #[inline]
  pub fn code(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Error::VT_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Error::VT_MESSAGE, None)}
  }
  #[inline]
  pub fn details(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Error::VT_DETAILS, None)}
  }
  #[inline]
  pub fn batch_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Error::VT_BATCH_ID, None)}
  }
}

impl ::flatbuffers::Verifiable for Error<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i32>("code", Self::VT_CODE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("details", Self::VT_DETAILS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("batch_id", Self::VT_BATCH_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorArgs<'a> {
    pub code: i32,
    pub message: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub details: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub batch_id: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorArgs {
      code: 0,
      message: None,
      details: None,
      batch_id: None,
    }
  }
}

pub struct ErrorBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code(&mut self, code: i32) {
    self.fbb_.push_slot::<i32>(Error::VT_CODE, code, 0);
  }
  #[inline]
  pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Error::VT_MESSAGE, message);
  }
  #[inline]
  pub fn add_details(&mut self, details: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Error::VT_DETAILS, details);
  }
  #[inline]
  pub fn add_batch_id(&mut self, batch_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Error::VT_BATCH_ID, batch_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Error<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Error");
      ds.field("code", &self.code());
      ds.field("message", &self.message());
      ds.field("details", &self.details());
      ds.field("batch_id", &self.batch_id());
      ds.finish()
  }
}
pub enum AuditRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuditRequest<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for AuditRequest<'a> {
  type Inner = AuditRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> AuditRequest<'a> {
  pub const VT_STREAM_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_TRACEPARENT: ::flatbuffers::VOffsetT = 6;
  pub const VT_BAGGAGE: ::flatbuffers::VOffsetT = 8;
  pub const VT_PAYLOAD_TYPE: ::flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD: ::flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    AuditRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AuditRequestArgs<'args>
  ) -> ::flatbuffers::WIPOffset<AuditRequest<'bldr>> {
    let mut builder = AuditRequestBuilder::new(_fbb);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.baggage { builder.add_baggage(x); }
    if let Some(x) = args.traceparent { builder.add_traceparent(x); }
    if let Some(x) = args.stream_id { builder.add_stream_id(x); }
    builder.add_payload_type(args.payload_type);
    builder.finish()
  }


  #[inline]
  pub fn stream_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(AuditRequest::VT_STREAM_ID, None)}
  }
  #[inline]
  pub fn traceparent(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(AuditRequest::VT_TRACEPARENT, None)}
  }
  #[inline]
  pub fn baggage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(AuditRequest::VT_BAGGAGE, None)}
  }
  #[inline]
  pub fn payload_type(&self) -> RequestPayload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RequestPayload>(AuditRequest::VT_PAYLOAD_TYPE, Some(RequestPayload::NONE)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(AuditRequest::VT_PAYLOAD, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_hash_batch(&self) -> Option<HashBatch<'a>> {
    if self.payload_type() == RequestPayload::HashBatch {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HashBatch::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_control_message(&self) -> Option<ControlMessage<'a>> {
    if self.payload_type() == RequestPayload::ControlMessage {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ControlMessage::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for AuditRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("stream_id", Self::VT_STREAM_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("traceparent", Self::VT_TRACEPARENT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("baggage", Self::VT_BAGGAGE, false)?
     .visit_union::<RequestPayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          RequestPayload::HashBatch => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<HashBatch>>("RequestPayload::HashBatch", pos),
          RequestPayload::ControlMessage => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<ControlMessage>>("RequestPayload::ControlMessage", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct AuditRequestArgs<'a> {
    pub stream_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub traceparent: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub baggage: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub payload_type: RequestPayload,
    pub payload: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for AuditRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuditRequestArgs {
      stream_id: None,
      traceparent: None,
      baggage: None,
      payload_type: RequestPayload::NONE,
      payload: None,
    }
  }
}

pub struct AuditRequestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> AuditRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stream_id(&mut self, stream_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditRequest::VT_STREAM_ID, stream_id);
  }
  #[inline]
  pub fn add_traceparent(&mut self, traceparent: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditRequest::VT_TRACEPARENT, traceparent);
  }
  #[inline]
  pub fn add_baggage(&mut self, baggage: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditRequest::VT_BAGGAGE, baggage);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: RequestPayload) {
    self.fbb_.push_slot::<RequestPayload>(AuditRequest::VT_PAYLOAD_TYPE, payload_type, RequestPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditRequest::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> AuditRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AuditRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<AuditRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for AuditRequest<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("AuditRequest");
      ds.field("stream_id", &self.stream_id());
      ds.field("traceparent", &self.traceparent());
      ds.field("baggage", &self.baggage());
      ds.field("payload_type", &self.payload_type());
      match self.payload_type() {
        RequestPayload::HashBatch => {
          if let Some(x) = self.payload_as_hash_batch() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        RequestPayload::ControlMessage => {
          if let Some(x) = self.payload_as_control_message() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("payload", &x)
        },
      };
      ds.finish()
  }
}
pub enum AuditResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuditResponse<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for AuditResponse<'a> {
  type Inner = AuditResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> AuditResponse<'a> {
  pub const VT_STREAM_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_TRACEPARENT: ::flatbuffers::VOffsetT = 6;
  pub const VT_BAGGAGE: ::flatbuffers::VOffsetT = 8;
  pub const VT_PAYLOAD_TYPE: ::flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD: ::flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    AuditResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AuditResponseArgs<'args>
  ) -> ::flatbuffers::WIPOffset<AuditResponse<'bldr>> {
    let mut builder = AuditResponseBuilder::new(_fbb);
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.baggage { builder.add_baggage(x); }
    if let Some(x) = args.traceparent { builder.add_traceparent(x); }
    if let Some(x) = args.stream_id { builder.add_stream_id(x); }
    builder.add_payload_type(args.payload_type);
    builder.finish()
  }


  #[inline]
  pub fn stream_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(AuditResponse::VT_STREAM_ID, None)}
  }
  #[inline]
  pub fn traceparent(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(AuditResponse::VT_TRACEPARENT, None)}
  }
  #[inline]
  pub fn baggage(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(AuditResponse::VT_BAGGAGE, None)}
  }
  #[inline]
  pub fn payload_type(&self) -> ResponsePayload {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ResponsePayload>(AuditResponse::VT_PAYLOAD_TYPE, Some(ResponsePayload::NONE)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(AuditResponse::VT_PAYLOAD, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_cracked_hash(&self) -> Option<CrackedHash<'a>> {
    if self.payload_type() == ResponsePayload::CrackedHash {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CrackedHash::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_cracked_batch(&self) -> Option<CrackedBatch<'a>> {
    if self.payload_type() == ResponsePayload::CrackedBatch {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CrackedBatch::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_status(&self) -> Option<Status<'a>> {
    if self.payload_type() == ResponsePayload::Status {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Status::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_error(&self) -> Option<Error<'a>> {
    if self.payload_type() == ResponsePayload::Error {
      self.payload().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Error::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for AuditResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("stream_id", Self::VT_STREAM_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("traceparent", Self::VT_TRACEPARENT, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("baggage", Self::VT_BAGGAGE, false)?
     .visit_union::<ResponsePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          ResponsePayload::CrackedHash => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<CrackedHash>>("ResponsePayload::CrackedHash", pos),
          ResponsePayload::CrackedBatch => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<CrackedBatch>>("ResponsePayload::CrackedBatch", pos),
          ResponsePayload::Status => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Status>>("ResponsePayload::Status", pos),
          ResponsePayload::Error => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Error>>("ResponsePayload::Error", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct AuditResponseArgs<'a> {
    pub stream_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub traceparent: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub baggage: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub payload_type: ResponsePayload,
    pub payload: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for AuditResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuditResponseArgs {
      stream_id: None,
      traceparent: None,
      baggage: None,
      payload_type: ResponsePayload::NONE,
      payload: None,
    }
  }
}

pub struct AuditResponseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> AuditResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stream_id(&mut self, stream_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditResponse::VT_STREAM_ID, stream_id);
  }
  #[inline]
  pub fn add_traceparent(&mut self, traceparent: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditResponse::VT_TRACEPARENT, traceparent);
  }
  #[inline]
  pub fn add_baggage(&mut self, baggage: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditResponse::VT_BAGGAGE, baggage);
  }
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: ResponsePayload) {
    self.fbb_.push_slot::<ResponsePayload>(AuditResponse::VT_PAYLOAD_TYPE, payload_type, ResponsePayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(AuditResponse::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> AuditResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AuditResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<AuditResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for AuditResponse<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("AuditResponse");
      ds.field("stream_id", &self.stream_id());
      ds.field("traceparent", &self.traceparent());
      ds.field("baggage", &self.baggage());
      ds.field("payload_type", &self.payload_type());
      match self.payload_type() {
        ResponsePayload::CrackedHash => {
          if let Some(x) = self.payload_as_cracked_hash() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponsePayload::CrackedBatch => {
          if let Some(x) = self.payload_as_cracked_batch() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponsePayload::Status => {
          if let Some(x) = self.payload_as_status() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        ResponsePayload::Error => {
          if let Some(x) = self.payload_as_error() {
            ds.field("payload", &x)
          } else {
            ds.field("payload", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("payload", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AuditResponse`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_audit_response_unchecked`.
pub fn root_as_audit_response(buf: &[u8]) -> Result<AuditResponse<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<AuditResponse>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AuditResponse` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_audit_response_unchecked`.
pub fn size_prefixed_root_as_audit_response(buf: &[u8]) -> Result<AuditResponse<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<AuditResponse>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AuditResponse` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_audit_response_unchecked`.
pub fn root_as_audit_response_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AuditResponse<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<AuditResponse<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AuditResponse` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_audit_response_unchecked`.
pub fn size_prefixed_root_as_audit_response_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AuditResponse<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<AuditResponse<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AuditResponse and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AuditResponse`.
pub unsafe fn root_as_audit_response_unchecked(buf: &[u8]) -> AuditResponse<'_> {
  unsafe { ::flatbuffers::root_unchecked::<AuditResponse>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AuditResponse and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AuditResponse`.
pub unsafe fn size_prefixed_root_as_audit_response_unchecked(buf: &[u8]) -> AuditResponse<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<AuditResponse>(buf) }
}
#[inline]
pub fn finish_audit_response_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<AuditResponse<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_audit_response_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<AuditResponse<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod fb
}  // pub mod lattice

